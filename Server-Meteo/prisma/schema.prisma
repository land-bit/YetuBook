// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Localisation {
  id         Int    @id @default(autoincrement())
  date       String
  time       String
  cityName   String
  country    String
  population Int
  timezone   Int?
  latitude   Int
  longitude  Int

  @@map("localisation")
}

model CurrentWeather {
  id          Int      @id @default(autoincrement())
  date        String
  dt          Int
  city        String
  time        String
  tempMin     Int
  tempMax     Int
  temperature Int
  humidity    Int
  rain        Float?
  snow        Float?
  pressure    Int
  description String
  base        String
  clouds      Int
  visibility  Int
  windSpeed   Int
  windGust    Float?
  windDeg     Int
  windDir     String
  windChill   Int
  feelsLike   Int
  dewPoint    Int
  weatherType String?
  weatherIcon String?
  uvi         Int
  alert       String
  createdAt   DateTime @default(now())

  @@map("currentweather")
}

model CurrentHour {
  id          Int      @id @default(autoincrement())
  date        String
  dt          Int
  time        String
  temperature Int
  humidity    Int
  description String?
  weatherType String?
  weatherIcon String?
  clouds      Int
  visibility  Int
  tempMin     Int
  tempMax     Int
  windSpeed   Int
  windGust    Float?
  windDeg     Int
  windDir     String
  windChill   Int
  rain        Float?
  snow        Float?
  pressure    Int
  pop         Int?
  sunrise     String
  sunset      String
  uvi         Int
  createdAt   DateTime @default(now())

  @@map("currenthour")
}

model ByHour {
  id             Int      @id @default(autoincrement())
  date           String
  shortdate      String
  dt             Int
  day            String
  time           String
  temperature    Int
  humidity       Int
  description    String?
  weatherType    String?
  weatherIcon    String?
  partOfTheDay   String
  periodOfTheDay String
  grndLevel      Int
  seaLevel       Int
  feelsLike      Int
  clouds         Int
  visibility     Int
  tempMin        Int
  tempMax        Int
  Kalmanfilter   Int
  windSpeed      Int
  windGust       Float?
  windDeg        Int
  windDir        String
  windChill      Int
  rain           Float?
  snow           Float?
  pressure       Int
  pop            Int?
  dewPoint       Int
  sunrise        String
  sunset         String
  uvi            Int
  createdAt      DateTime @default(now())

  @@map("byhour")
}

model Next5days {
  id             Int      @id @default(autoincrement())
  date           String
  shortdate      String
  day            String
  dt             Int
  time           String
  temperature    Int
  humidity       Int
  description    String?
  weatherType    String?
  weatherIcon    String?
  partOfTheDay   String
  periodOfTheDay String
  grndLevel      Int
  seaLevel       Int
  feelsLike      Int
  clouds         Int
  visibility     Int
  tempMin        Int
  tempMax        Int
  Kalmanfilter   Int
  windSpeed      Int
  windGust       Float?
  windDeg        Int
  windDir        String
  windChill      Int
  rain           Float?
  snow           Float?
  pressure       Int
  pop            Int?
  sunrise        String
  sunset         String
  dewPoint       Int
  uvi            Int
  createdAt      DateTime @default(now())

  @@map("next5days")
}

model AirPollution {
  id   Int    @id @default(autoincrement())
  date String
  dt   Int
  time String
  aqi  Int?
  pm25 Float?
  pm10 Float?
  o3   Float?
  no2  Float?
  so2  Float?
  co   Float?

  createdAt DateTime @default(now())

  @@map("airpollution")
}

model Post {
  id        String   @id @default(cuid())
  content   String
  imageUrl  String?
  authorId  String   @db.Uuid
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  comments Comment[]
  likes    Like[]
  shares   Share[]
  author   Profile   @relation(fields: [authorId], references: [id], onDelete: Cascade)
}

model Comment {
  id        String   @id @default(cuid())
  content   String
  authorId  String   @db.Uuid
  post      Post     @relation(fields: [postId], references: [id])
  postId    String
  createdAt DateTime @default(now())

  replies   Reply[]
  author    Profile @relation(fields: [authorId], references: [id], onDelete: Cascade)
  profileId String?
}

model Reply {
  id        String   @id @default(cuid())
  content   String
  authorId  String   @db.Uuid
  comment   Comment  @relation(fields: [commentId], references: [id], onDelete: Cascade)
  commentId String
  createdAt DateTime @default(now())
}

model Like {
  id        String   @id @default(cuid())
  authorId  String   @db.Uuid
  post      Post     @relation(fields: [postId], references: [id], onDelete: Cascade)
  postId    String
  createdAt DateTime @default(now())

  @@unique([authorId, postId]) // un utilisateur ne peut liker qu’une fois
}

model Share {
  id        String   @id @default(cuid())
  authorId  String   @db.Uuid
  post      Post     @relation(fields: [postId], references: [id], onDelete: Cascade)
  postId    String
  createdAt DateTime @default(now())
}

model Profile {
  id            String   @id @db.Uuid
  email         String?  @unique
  fullName      String?
  avatarUrl     String?
  createdAt     DateTime @default(now())
  canMessageIds String[] @default([]) @db.Uuid

  posts            Post[]
  comments         Comment[]
  sentMessages     Message[]       @relation("SentMessages")
  receivedMessages Message[]       @relation("ReceivedMessages")
  sentRequests     FriendRequest[] @relation("SentRequests")
  receivedRequests FriendRequest[] @relation("ReceivedRequests")
}

model Message {
  id         String   @id @default(uuid())
  senderId   String   @db.Uuid
  receiverId String   @db.Uuid
  content    String
  createdAt  DateTime @default(now())

  sender   Profile @relation("SentMessages", fields: [senderId], references: [id])
  receiver Profile @relation("ReceivedMessages", fields: [receiverId], references: [id])
}

// enum pour l'état d'une demande
enum FriendRequestStatus {
  PENDING
  ACCEPTED
  REJECTED
  BLOCKED
}

model FriendRequest {
  id          String              @id @default(cuid())
  requesterId String              @db.Uuid
  receiverId  String              @db.Uuid
  status      FriendRequestStatus @default(PENDING)
  message     String? // optionnel : message d'accompagnement
  createdAt   DateTime            @default(now())
  updatedAt   DateTime            @updatedAt

  requester Profile @relation("SentRequests", fields: [requesterId], references: [id])
  receiver  Profile @relation("ReceivedRequests", fields: [receiverId], references: [id])

  @@unique([requesterId, receiverId]) // empêche demandes dupliquées same direction
}
